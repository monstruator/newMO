/*      ПО КОНТРОЛЛЕРА ИНТЕРФЕСА ARINC429 CPCI429-1      18/07/2005г.
   cpci1p.h - INCLUDE-файл библиотеки функций для пользовательского ПО
	управления работой модуля интерфейса ARINC429 CPCI429-1,
	включен в пример пользовательской программы cpci1p.cpp.exe, в которой
	адреса портов платы, номер прерывания IRQ и режим работы с Заглушкой
	или в Контроле, задаются как опции при пуске программы cpci1p.exe.

 Константа SA  - база адресов портов PCI платы CPCI429_1, SA()+0..Fh
 Константа PLX - база адресов портов PCI PLX платы CPCI429_1, PLX()+0..7Fh
 Константа INT - байт номера Прерывания IRQ PCI, область задания INT=3,..15,0,
		 cоответствует IRQ3,..IRQ15, 0- INT не используется
 Параметры SA,PLX,INT назначаются в системе P&P при загрузке системы и могут
быть получены пользователем специальными функциями BIOS или запуском программы
pci_find.exe, постовляемой в ПО платы.
/***************************************************************************/
/*	16-РАЗРЯДНЫЕ ПОРТЫ ШИНЫ PCI МОДУЛЯ СРСI429-1-Х
Рег 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00  Смещ. Реж.   Примечание
РА               ADR_RAM(15-00)                       +0   R/W  рег.Адреса ОЗУ
РД1     DATA_RAM(15-00) c инкрементом РА(9..0)        +2   R/W  Инкремент РА
РМ  МА М2  х  x МВ  x  x ТР  х  x Т1 Т0 K2  х С2 С1   +4    W   рег.Управления
РИД      IDN=6030h/6020h/6010h=СPCI429-3/2/1          +4    R   рг.Идентификатор
РВ  ГА Ф2 Ф1 ФО ФВ   Вектор_ВП(10..0)_по_флагу_ФВ     +6    R   с обнл.флагов Ф
ОК   . . . . . . . . . . . Х . . . . . . . . . . .    +6    W   сброс блокир.IRQ
     . . . . . . . . . . . X . . . . . . . . . X  1   +6    W   сброс FIFO IRQ
     . . . . . . . . . . . X . . . . . . . . . 1  X   +6    W   форм.ИСПР ОК
РДВ  . . . .  Х . . . . . . -------РК_ДВ(8-1)------   +8    W   рег. выходн.РК
ДП1 ГА Ф2 Ф1 0  0  0  0 ДПТ ------РК_ДПК(8-1)------   +8    R   рг.входн. РК ОК
РД2       DATA_RAM(15-00) c инкрементом РА(9..0)      +A   R/W  Инкремент РА
ДП2 ГА Ф2 Ф1 0  0  0  0 ДПТ ------РК_ДПБ(8-1)------   +С   R/W  рг.входн. РК БС
РСА KС  х  х АП -1 +1 ЧБ1,0  x  х  х ПВ  х  x ЧВ1,0   +С    W   рг.Упр.КВА
РВ1 ------ПК(16..09)-----   --ПК(8..1)или ПК(1..8)-   +С    W   рг.ДКВАмл.
РВ2 ------------------ПК(32..17)-------------------   +Е    W   рг.ДКВАст.

Где: МА=0/1-на выходах канала КВ1 программный КВ1/аппаратный КВА
     М2-маска Прер. по ДП2, МВ-маска Прер. по ФВ,   ТР=1-тест РК;
     Т1,0=1/2/3/0 -формир. флага Ф1 от ДПТ по фронту/спаду/перепаду/нет Прер
     К2=0/1 - формир. флага Ф2 от ДП2 по переключ. в "логич" 0/1
     C2,C1=0/1-выходы РК=ДВ2,ДВ1/СВ2,СВ1
     ГА=1-готовность принять данные канала КВА
РСА: КС=0/1- канал КВА с формир.бита Контр./с блокировкой.
     АП=0/1-выдача адреса параметра КВА ПК(1..8)/ПК(8..1)
     -1,+1,ЧБ()=0/1/2/3=число бит слова КВА =8/16/24/32(-1 или +1)
     ПВ=0/1-пауза слова ПК КВА 4Т/8Т
     ЧВ()=0/1/2/3-частота ПК КВА 12.5/50/100/резерв КГц

       АДРЕСНОЕ ПРОСТРАНСТВО ОЗУ МОДУЛЯ (64К 16-р.слов)
0000..17FFh - зона пользователя, не доступна процессору модуля
1800..1FFFh - зона блоков управления каналов ПК
2000..2FFFh - зона управления модуля
3000..3000h - зона состояния модуля, не доступна по записи для PCI
4000..7FFFh - зона буферов приема ПК или расписания каналов КП ПК
8000..BFFFh - зона буферов выдачи ПК или расписания каналов КВ
C000..FFFFh - зона глобальных буферов приема-выдачи ПК
     в т.ч.
1800+80h*i -16 блоков управления каналов КП1-КП16(i=0-Fh) по 8 слов на канал.
1840+80h*i - 8 блоков управления каналов КB1-КB8(i=0-7h) по 8 слов на канал.
4000+400h*i -16 буферов данных приема ПК или расписания каналов КП1-КП16.
8000+400h*i -8  буферов данных выдачи ПК или расписания каналов КВ1-КВ8.
/**************************************************************************/
unsigned int SA;	//формат  SA=xxx0h +10h
unsigned int PLX;       //формат PLX=xx00h +80h
unsigned char INT,IntFlag;//формат INT=3-15 и INT=0, если без прерываний

unsigned int rj_pc;  //в перемен. rj_pc функц. pc_rj записывает код
		     //Идентификатора, если модуль не обнаружен, rj_pc=0

unsigned char msk1,msk2; //в перемен. сохраняется исходн.код маски Прр.IRQ

//***Переменная обявляемая Пользователем и устанавливаемая ПО CPC429-1 **//
unsigned char err_pc=0;  //в переменной формир. код ошибки при неисправном
			 // выполнении вызываемых функций, err_pc=0-исправно
//***Набор функций управления режимами работы платы CРСI429-1 //***
//************Функции вызываемые ПО CPCI429-1*************************//
void interrupt pc_int (); //функц. обработки ПРР для INT!=0, вызывается
 //при поступлении вх.сигнала INT, программа обработки пишется пользователем
 //приведена в примере pc4p.cpp, в общем случае может включать Чтение в начале
 //и восстановление в конце регистра РА, если в обработке модифицируется рег.РА;
 //может включать вызов функции pc_rrv() чтения рег.РВ и вызов функц. pc_wrv()-
 //снятия блокировки IRQ; при выходе обязательно должна включать запись в порт
 //outpw(PLX+0x4c,0xd53) - отбой прерывания и стандартный выход

void interrupt (*oldfunc_int)(); //функц. cохраняющая OLD вектор ПРР IRQ

//************Функции вызываемые Пользователем*************************//
unsigned int pc_rj ();
 //функц. читает рг.РИД Идентификатора в переменную rj_pc - программ.RESET,
 //если модуль не обнаружен, err_pc=2; rj_pc=6010h/6020h/6030h=CPCI429-1-1/2/3=16R8T/8RT/8R4T
unsigned int pc_rj ()
 { rj_pc=inpw (SA+4);					//RESET модуля
   if ((rj_pc!=0x6030)&&(rj_pc!=0x6020)&&(rj_pc!=0x6010)) err_pc=2; //модуль не обнаружен!
		return (rj_pc);
 };
/*************************************************************************/
void pc_ok (); //функ. формирования сигнала ИСПР ОК и снятие блокир. Прер.IRQ
void pc_ok ()     { outpw (SA+6,2); };
/*************************************************************************/
void pc_sf (); //функ. сброса FIFO IRQ и снятие блокир. Прер.IRQ
void pc_sf ()     { outpw (SA+6,1); };
/*************************************************************************/
void pc_contr ();
 //функция контроля задания Констант SA,PLX,INT вызывается в начале программы
 //пользователя, выполняет чтение рег. Идентификатора в перемен. rj_pc и
 //программный RESET модуля, устанавливает новую функцию и маски для вектора
 //ПРЕР INT, сохраняет старые установки IRQ, использует задаваемые константы
 //SA,PLX,INT и перем. msk1,msk2, при ошибке задания констант или не
 //обнаружении модуля формир. код err_pc и не устанавливает прерывание
void pc_contr () //функция контроля правильности задания Констант SA,PLX,INT
{  	unsigned int adr,m;
   if (SA&0xF)   		err_pc=1;  //проверка формата SA
   if (PLX&0x7F) 		err_pc=1;  //проверка формата PLX
   if (INT)
   {	if ((INT<3)||(INT>15))  err_pc=1; //проверка формата INT=0,3-15
   }
	if (err_pc)	return;

//		outp (PLX+0x4c,0xd12);	// Прер. закрыты
		pc_rj ();	  		// RESET модуля
	if (err_pc) 	return;		 	//Адаптер не обнаружен!
/*
	if (INT)              // for int<8
	{  if (INT<8)
	   { msk1=inp (0x21);	//запоминаем OLD рег. маски ПРР ISA
	     oldfunc_int=getvect (INT+0x8); setvect (INT+0x8,pc_int);
	     msk2=1;	msk2<<=(INT);
	     outp (0x21,msk1 & (~msk2));   //Устанавливаем новую маску ПРР
	   }
	   else
	   { msk2=inp (0xa1);	//запоминаем OLD рег. маски ПРР ISA
	     oldfunc_int=getvect (INT+0x68); setvect (INT+0x68,pc_int);
	     msk1=1;	msk1<<=(INT-8);
	     outp (0xa1,msk2 & (~msk1));   //Устанавливаем новую маску ПРР
	   }
*/
//	 outpw (PLX+0x4c,0xd53);	       // Прерыв. INT1 открыто
//}	
};
/**************************************************************************/
 //функция Записи в регистр-порт (SA+2) РД DRAM данных d
void pc_wd (unsigned int d);
void pc_wd (unsigned int d)	{ outpw (SA+2,d); };
/**************************************************************************/
unsigned int pc_rd (); //функ. Чтения рег.-порта (SA+2) РД DRAM
unsigned int pc_rd ()
 { unsigned int drm;
	drm=inpw (SA+2);	return (drm); };
/**************************************************************************/
 //функ. записи в ОЗУ модуля слова данных d по адресу а
void pc_wm (unsigned int a,unsigned int d);
void pc_wm (unsigned int a,unsigned int d)
 {	outpw (SA,a);         //ЗП в РА адреса а
	outpw (SA+2,d); };	//ЗП в РД данных d
/**************************************************************************/
 //функ. защищенной записи в ОЗУ модуля 32-х разрядного слова ПК данных d
 //по четному адресу а
void pc_wml (unsigned int a,unsigned long d);
void pc_wml (unsigned int a,unsigned long d)
 {	outpw (SA,a&0xfffe);  //ЗП в РА адреса а
	outpw (SA+10,d);	//ЗП в РД2 младших данных d[15-0]
	outpw (SA+10,d>>16);	//ЗП в РД2 старших данных d[31-16]
 };
/**************************************************************************/
 //функция чтения из ОЗУ модуля cлова данных по адресу а
unsigned int pc_rm (unsigned int a);
unsigned int pc_rm (unsigned int a)
 { unsigned int drm;
	outpw (SA,a);    drm = inpw (SA+2);	   return (drm); };
/**************************************************************************/
 //функция защищенного чтения из ОЗУ модуля 32-х разрядного cлова данных ПК
 //по четному адресу а
unsigned long pc_rml (unsigned int a);
unsigned long pc_rml (unsigned int a)
 { unsigned long drm, dm;
	outpw (SA,a&0xfffe);	drm = inpw (SA+10);
				dm  = inpw (SA+10);
	drm = (dm<<16)|drm;	return (drm); };
/**************************************************************************/
void pc_wra (unsigned int d); //функ. Записи Данных в рег.РА
void pc_wra (unsigned int d)  { outpw (SA,d); };
/**************************************************************************/
unsigned int pc_rra ();       //функ. Чтения данных регистра РА
unsigned int pc_rra ()
 {	unsigned int drm;	drm = inpw (SA);      return (drm); };
/**************************************************************************/
 //функ. Записи Данных в регистр РМ модуля
void pc_wrm (char ma,char m2,char mb,char tp,char t,char k2,char c2,char c1);
  //РМ(15)=ma=0/1 -запрет/разрешение аппаратного канала КВА КВ1
  //РМ(14)=m2=0/1 -разрешение/запрет прерыв. по флагу Ф2 от РК ДПК2
  //РМ(11)=mb=0/1 -разрешение/запрет прерыв. по флагам ФО,ФВ от FIFO IRQ
  //РМ(8)=tp=0/1 -входы РК с линии/Тест РК- ДПК[]=ДВ[],ДПТ=ДВ1
  //РМ(5,4)=t=1/2/3/0-реж. форм. фл.Ф1 по фронту/спаду/перепаду/нет РК ДПТ
  //РМ(3)=К2=0/1-режим формир. флага Ф2 по переходу РК ДПК2 в логич.0/1
  //РМ(1,0)=C2,C1=0/1 -режим выходов РК ТТЛ ДВ2,1=ДВ2,ДВ1/CКB4,CКB1
void pc_wrm (char ma,char m2,char mb,char tp,char t,char k2,char c2,char c1)
 { unsigned int d=0;
     if (ma) d=0x8000;		if (m2) d=(d+0x4000);
     if (mb) d=(d+0x800);	if (tp) d=(d+0x100);
     d=(d+((t&3)<<4));		if (k2) d=(d+8);
     if (c2) d=(d+2);		outpw (SA+4,d+(c1&1)); };
/**************************************************************************/
void pc_wrv (); //функ. Записи "0" в рег.РВ, снятие блокир. Прер.IRQ
void pc_wrv ()    { outpw (SA+6,0); };
/**************************************************************************/
unsigned int pc_rrv (); 	//функц. чтения рег.РВ, сброс флагов Ф РВ
unsigned int pc_rrv ()          //drm(15-11)=флаги ГА,Ф2,Ф1,ФО,ФВ
 {	unsigned int drm;       //drm(10-0)=вектор флага прерыв.ФВ
	drm=inpw (SA+6);	return (drm); };
/**************************************************************************/
void pc_do (unsigned int d); //функ.Записи данных d в регистр РДВ РК ДВ
void pc_do (unsigned int d) { outpw (SA+8,d);	}; //РК ДB(8-1)=d(7-0)
/**************************************************************************/
unsigned int pc_di1 (); //функц.чтения регистра ДП1 РК ДПK(8-1)
unsigned int pc_di1 ()
 { unsigned int drm;	drm=inpw (SA+8);	return (drm); };
/**************************************************************************/
unsigned int pc_di2 (); //функц.чтения регистра ДП2 РК ДПБ(8-1)
unsigned int pc_di2 ()
 { unsigned int drm;	drm=inpw (SA+12);	return (drm); };
/**************************************************************************/
void pc_dal (unsigned int d); //функ.Записи младш.данных d ПК КВА в порт +Ch
void pc_dal (unsigned int d) { outpw (SA+12,d); }; //ПК КВА (16-1)
/**************************************************************************/
void pc_dah (unsigned int d); //функ.Записи старш.данных d ПК КВА в порт +Еh
void pc_dah (unsigned int d) { outpw (SA+14,d); }; //ПК КВА (32-17)
/**************************************************************************/
void pc_da (unsigned long d); //функ.Записи 32-х разр.данных d ПК КВА в порты
void pc_da (unsigned long d)
 {	outpw (SA+12,d);	//ЗП в РВ1 младших данных d[15-0]
	outpw (SA+14,(d>>16));//ЗП в РВ2 старших данных d[31-16]
 };
/**************************************************************************/
void pc_fsi (char s1,char s2,char s3,char s4,char s5,char s6,char s7,char s8,
char s9,char s10,char s11,char s12,char s13,char s14,char s15,char s16);
  //функция настройки каналов КП на частоту ПК(s[1,0]) и режим контроля(s[3]),
  //должна вызываться только в режиме Настройка, обычно один раз после функ.
  //pc_tvk в нач. прогр. пользователя, где: sN - N-номер кан.КП,
  //s[1,0]=0/1/2/3=канал Выкл./11-14,5/48/100 КГц, s[3]=0/1=контроль/бл.контр.
void pc_fsi (char s1,char s2,char s3,char s4,char s5,char s6,char s7,char s8,
char s9,char s10,char s11,char s12,char s13,char s14,char s15,char s16)
 { 	pc_wm (0x1807,s1&0xb);	pc_wm (0x1887,s2&0xb);
	pc_wm (0x1907,s3&0xb);	pc_wm (0x1987,s4&0xb);
	pc_wm (0x1a07,s5&0xb);	pc_wm (0x1a87,s6&0xb);
	pc_wm (0x1b07,s7&0xb);	pc_wm (0x1b87,s8&0xb);
	pc_wm (0x1c07,s9&0xb);	pc_wm (0x1c87,s10&0xb);
	pc_wm (0x1d07,s11&0xb);	pc_wm (0x1d87,s12&0xb);
	pc_wm (0x1e07,s13&0xb);	pc_wm (0x1e87,s14&0xb);
	pc_wm (0x1f07,s15&0xb);	pc_wm (0x1f87,s16&0xb);
 };
/**************************************************************************/
void pc_fso (char s1,char s2,char s3,char s4,char s5,char s6,char s7,char s8);
  //функция настройки каналов КВ на частоту, паузу ПК и режим бита контроля,
  //вызываться аналогично pc_fsi(), где:  sN - N-номер кан.КВ,
  //s[1,0]=0/1/2/3=канал Выкл./12,5/50/100 КГц, s[2]=0/1=пауза ПК 4Т/8Т
  //s[3]=0/1=в ПК(32) формируется бит контроля/ПК(32)-информационный
void pc_fso (char s1,char s2,char s3,char s4,char s5,char s6,char s7,char s8)
 { 	pc_wm (0x1847,s1&0xf);	pc_wm (0x18c7,s2&0xf);
	pc_wm (0x1947,s3&0xf);	pc_wm (0x19c7,s4&0xf);
	pc_wm (0x1a47,s5&0xf);	pc_wm (0x1ac7,s6&0xf);
	pc_wm (0x1b47,s7&0xf);	pc_wm (0x1bc7,s8&0xf);
 };
/**************************************************************************/
void pc_si_ap (char s,char buf,unsigned char ap,char intap);
  //функция настройки БУК канала КП=s=1..16 на непрер. прием по адресу параметра
  //в буфер buf=0/1=БКП1/БКП2 c прерыванием по адр.парам. ap=0..FFh, if (intap)
void pc_si_ap (char s,char buf,unsigned char ap,char intap)
 {
   if (intap)	pc_wm (0x1802+(((s-1)&0xf)<<7),0x2000+(0xff&ap));
    else	pc_wm (0x1802+(((s-1)&0xf)<<7),(0xff&ap));
		pc_wm (0x1800+(((s-1)&0xf)<<7),0x2000+((buf&1)<<10));
 };
/**************************************************************************/
void pc_si_gp (char s);
  //функция настройки БУК канала КП=s=1..16 на непрерыв. прием по расписанию
void pc_si_gp (char s)
 { 	        	pc_wm (0x1802+(((s-1)&0xf)<<7),0);
			pc_wm (0x1800+(((s-1)&0xf)<<7),0x3000);
 };
/**************************************************************************/
void pc_si_fa (char s,char buf,unsigned char ap,unsigned int nw,char intap,char intnw);
  //функция настройки БУК канала КП=s=1..16 на однокр. прием файла числа слов nw
  //начиная с заданного ap=0..FFh в буфер buf=0/1=БКП1/БКП2 c прерыванием
  //по приему ap, if (intap);  c прерыванием по приему числа слов nw, if (intnw).
void pc_si_fa (char s,char buf,unsigned char ap,unsigned int nw,char intap,char intnw)
 {
   if (intap)   pc_wm (0x1802+(((s-1)&0xf)<<7),0x2000+(0xff&ap));
      else      pc_wm (0x1802+(((s-1)&0xf)<<7),(0xff&ap));
   if (intnw)   pc_wm (0x1800+(((s-1)&0xf)<<7),0x8000+((buf&1)<<10)+(nw&0x3ff));
      else      pc_wm (0x1800+(((s-1)&0xf)<<7),((buf&1)<<10)+(nw&0x3ff));
 };
/**************************************************************************/
void pc_si_fu (char s,char buf,unsigned int nw,char intnw);
  //функция настройки БУК канала КП=s=1..16 на однокр.прием файла числа слов nw
  //начиная с первого слова в буфер buf=0/1=БКП1/БКП2 c прерыванием
  //по приему числа слов nw, if (intnw).
void pc_si_fu (char s,char buf,unsigned int nw,char intnw)
 {
	     pc_wm (0x1802+(((s-1)&0xf)<<7),0);
  if (intnw) pc_wm (0x1800+(((s-1)&0xf)<<7),0x9000+((buf&1)<<10)+(nw&0x3ff));
     else    pc_wm (0x1800+(((s-1)&0xf)<<7),0x1000+((buf&1)<<10)+(nw&0x3ff));
 };
/**************************************************************************/
void pc_si_fc (char s,char buf,unsigned char ap,unsigned int nw,char intap);
  //функция настройки БУК канала КП=s=1..16 на цикл. прием файла числа слов nw
  //начиная с первого слова в буфер buf=0/1=БКП1/БКП2 c прерыванием
  //по приему слова с ap=0..FFh, if (intap);
void pc_si_fc (char s,char buf,unsigned char ap,unsigned int nw,char intap)
 {
    if (intap)  pc_wm (0x1802+(((s-1)&0xf)<<7),0x2000+(0xff&ap));
       else     pc_wm (0x1802+(((s-1)&0xf)<<7),(0xff&ap));
		pc_wm (0x1800+(((s-1)&0xf)<<7),0x1800+((buf&1)<<10)+(nw&0x3ff));
 };
/**************************************************************************/
void pc_si_rs (char s,char fl);
  //функция обнуления слов СКП+5(fl=1) или СФП+6(fl=0) БУК канала КП=s=1..16
void pc_si_rs (char s,char fl)
 { 	    if (fl)	pc_wm (0x1805+(((s-1)&0xf)<<7),0);
		else	pc_wm (0x1806+(((s-1)&0xf)<<7),0);
 };
/**************************************************************************/
unsigned int pc_si_st (char s,char cm);
 //функц.чтения состояния БУК канала КП=s=1..16, где cm=0..7 - смещение в БУК
unsigned int pc_si_st (char s,char cm)
 { unsigned int drm;
	drm=pc_rm(0x1800+(((s-1)&0xf)<<7)+(cm&7));  return (drm);
 };
/**************************************************************************/
void pc_soa (char kc,char ma,char bit,char tp,char tf);
 //функция режимов выдачи слова ПК аппаратного канала КВА КВ1 с частотой
 //tf=0/1/2=12.5/50/100кГц, с длительностью паузы tp=0/1=4Т/8T, с
 //колич.бит ПК bit=0/1/2/3=8/16/24/32,4/5/6/7=9/17/25/33,8/9/a/b=7/15/23/31
 //c ma=0/1=инверсией/без инверсии Адреса Парметра ПК,
 //с kc=0/1=c формированием бита Контроля/без бита Контроля
 void pc_soa (char kc,char ma,char bit,char tp,char tf)
 {
 outpw (SA+12,(((kc&1)<<15)+((ma&1)<<12)+((bit&15)<<8)+((tp&1)<<4)+(tf&3)));
 };
/**************************************************************************/
void pc_so_uf (char s,char buf,unsigned int nw,char intnw);
 //функция настройки БУК канала КВ=s=1..8 на однокр. выдачу числа слов nw
 //из буфера buf=0/1=БКВ1/БКВ2 c прерыванием по концу кадра выдачи, if (intnw)
void pc_so_uf (char s,char buf,unsigned int nw,char intnw)
 {
    if (intnw)	pc_wm (0x1840+(((s-1)&7)<<7),0x8000+((buf&1)<<10)+(nw&0x3ff));
       else     pc_wm (0x1840+(((s-1)&7)<<7),((buf&1)<<10)+(nw&0x3ff));
 };
/**************************************************************************/
void pc_so_cf (char s,char buf,unsigned int nw,char intnw);
  //функция настройки БУК канала КВ=s=1..8 на циклич. выдачу числа слов nw
  //из буфера buf=0/1=БКВ1/БКВ2 c прерыванием по концу кадра выдачи, if (intnw)
void pc_so_cf (char s,char buf,unsigned int nw,char intnw)
 {
   if (intnw)  pc_wm (0x1840+(((s-1)&7)<<7),0x8800+((buf&1)<<10)+(nw&0x3ff));
      else     pc_wm (0x1840+(((s-1)&7)<<7),0x800+((buf&1)<<10)+(nw&0x3ff));
 };
/**************************************************************************/
void pc_so_cfr (char s,char buf,unsigned int nw,char intnw);
 //функция настройки БУК канала КВ=s=1..8 на циклич. выдачу числа слов nw
 //из буфера buf=0/1=БКВ1/БКВ2 c прерыванием по концу кадра выдачи, if (intnw),
 //c обнулением параметра выдачи, после передачи его в канал.
void pc_so_cfr (char s,char buf,unsigned int nw,char intnw)
 {
   if (intnw) pc_wm (0x1840+(((s-1)&7)<<7),0x9800+((buf&1)<<10)+(nw&0x3ff));
      else    pc_wm (0x1840+(((s-1)&7)<<7),0x1800+((buf&1)<<10)+(nw&0x3ff));
 };
/**************************************************************************/
void pc_so_gv (char s,unsigned int nw,char intnw);
  //функция настройки БУК канала КВ=s=1..8 на цикл. выдачу числа слов nw
  //по расписанию c прерыванием по концу кадра выдачи, if (intnw).
void pc_so_gv (char s,unsigned int nw,char intnw)
 {  if (intnw)	pc_wm (0x1840+(((s-1)&7)<<7),0xa000+(nw&0x7ff));
	else	pc_wm (0x1840+(((s-1)&7)<<7),0x2000+(nw&0x7ff));
 };
/**************************************************************************/
void pc_so_rs (char s,char fl);
  //функция обнуления слов СКВ+5(fl=1) или СФВ+6(fl=0) БУК канала КВ=s=1..8
void pc_so_rs (char s,char fl)
 {  if (fl)	pc_wm (0x1845+(((s-1)&7)<<7),0);
    else	pc_wm (0x1846+(((s-1)&7)<<7),0);
 };
/**************************************************************************/
unsigned int pc_so_st (char s,char cm);
 //функц.чтения состояния БУК канала КB=s=1..8, где cm=0..7 - смещение в БУК
unsigned int pc_so_st (char s,char cm)
 { unsigned int drm;
	drm=pc_rm(0x1840+(((s-1)&7)<<7)+(cm&7));  return (drm);
 };
/**************************************************************************/
void set_kop (char kop);
  //функция задания команды КОП без параметров
void set_kop (char kop)  { pc_wm(0x2008,kop&0x3f);  };
/**************************************************************************/
void set_kop1 (char kop,unsigned int p);
  //функция задания команды КОП с одним параметрoм
void set_kop1 (char kop,unsigned int p)
 { pc_wm(0x2009,p);   pc_wm(0x2008,kop&0x3f);  };
/**************************************************************************/
void set_kop2 (char kop,unsigned int p1,unsigned int p2);
  //функция задания команды КОП с двумя параметрами
void set_kop2 (char kop,unsigned int p1,unsigned int p2)
 { pc_wm(0x2009,p1);   pc_wd(p2);   pc_wm(0x2008,kop&0x3f);  };
/**************************************************************************/
void set_kop_kpp (unsigned int p1,unsigned long p2);
  //функция задания команды КОП КПП - принять параметр (три параметра)
void set_kop_kpp (unsigned int p1,unsigned long p2)
 { pc_wm(0x2009,p1);   pc_wd(p2);   pc_wd(p2>>16);  pc_wm(0x2008,3);  };
/**************************************************************************/
unsigned int st_kop ();
 //функц. возврата состояния блока команд БКОП, должна вызываться пользователем
 //после установки задания команды КОП для контроля спуска или исполнения
 //задания, если КОП прошел - возвращает "0"-значение.
unsigned int st_kop ()
 { unsigned int drm;	drm=(pc_rm(0x2008)|pc_rm(0x200c));  return (drm);
 };
/*************************************************************************/
unsigned long st_kop_kvp ();
 //функция возврата параметра ПК из блока КОП после выполнения КОП КВП
 //вернуть параметр с обнулением, возвращает 32-х р. cлово ПК
unsigned long st_kop_kvp ()
 { unsigned long drm,dm;
	drm = pc_rm(0x200a);	dm = pc_rd();
	drm = (dm<<16)|drm;	return (drm);
 };
/*************************************************************************/
void si_tb (char s, unsigned int ap, unsigned int a);
 //функц. записи в ОЗУ слова данных таблиц Прогр.Распис. без прерывания для
 //одного заданного Параметра ПК с ap=0..3FFh=ПК(10,9,1-8) входного канала
 //s=1-16(КП1-16), c записью ПК в глобальн.буфер A=C000-FFFFh по адресу a.
 //формат данных расписания каналов КП: DTAB(15-0)= 0 х 1 ARAM(13-1)
void si_tb (char s, unsigned int ap, unsigned int a)
 {    pc_wm (0x4000+(((s-1)&0xf)<<10)+(ap&0x3ff),0x6000|(a>>1));
 };
/**************************************************************************/
void si_tb_int (char s, unsigned int ap, unsigned int a);
 //функц. записи в ОЗУ слова данных таблиц Прогр.Распис. с прерыванием  для
 //одного заданного Параметра ПК с ap=0..3FFh=ПК(10,9,1-8) входного канала
 //s=1-16(КП1-16) c записью ПК в глобальн.буфер A=C000-FFFFh по адресу a.
 //формат данных расписания каналов КП: DTAB(15-0)= 1 х 1 ARAM(13-1)
void si_tb_int (char s, unsigned int ap, unsigned int a)
 {    pc_wm (0x4000+(((s-1)&0xf)<<10)+(ap&0x3ff),0xe000|(a>>1));
 };
/**************************************************************************/
void so_tb (char s, unsigned int nw, unsigned int a);
 //функц. записи в ОЗУ слова данных таблиц Прогр.Распис. для выходного канала
 //s=1-8(КВ1-8), функция задает адрес a Параметра выдачи ПК из глобальн.буфера
 //A=C000-FFFFh, который будет выдан в канал по номеру слова nw=0..3FFh без
 //обнуления параметра, формат данных расписания: DTAB(15-0)= 001 ARAM(13-1)
void so_tb (char s, unsigned int nw, unsigned int a)
 {    pc_wm (0x8000+(((s-1)&7)<<10)+(nw&0x3ff),0x2000|(a>>1));
 };
/**************************************************************************/
void so_tb_clr (char s, unsigned int nw, unsigned int a);
 //то же, что so_tb, но c обнулением параметра выдачи,
 //формат данных расписания: DTAB(15-0)= 011 ARAM(13-1)
void so_tb_clr (char s, unsigned int nw, unsigned int a)
 {    pc_wm (0x8000+(((s-1)&7)<<10)+(nw&0x3ff),0x6000|((a>>1)&0x1fff));
 };
/**************************************************************************/
void so_tb_gap (char s, unsigned int nw, unsigned int n);
 //задание в расписании канала s(1-8) после слова nw[0..1023] выдать паузу
 //длительностью [n+1] слов ПК, где n=0..511
void so_tb_gap (char s, unsigned int nw, unsigned int n)
 {    pc_wm (0x8000+(((s-1)&7)<<10)+(nw&0x3ff),(n&0x1ff));
 };
/*************************************************************************/
void pc_end ();
 //функция закрытия платы CPCI429-1, вызывает RESET платы и устанавливает
 //старые функции для векторов обраб. ПРЕР
void pc_end ()		//функция закрытия платы CPCI429-1
{       outp (PLX+0x4c,0x502);	// прерывания закрыты
	inpw (SA+4);			// RESET модуля
/*
   if (INT) { if (INT<8)
		{	setvect (INT+0x8,oldfunc_int);	// for irq<8
			outp (0x21,msk1);	//запись OLD маски
		}
		else	{ 	setvect (INT+0x68,oldfunc_int);	// for irq>8
				outp (0xa1,msk2);	//запись OLD маски
}            }         
*/ };

// Используемые коды (err_pc) в функциях ПО
// (err_pc)=1 -ошибка задания констант SA,PLX,INT в проверке функ.pc_contr
// (err_pc)=2 -не найден модуль(Идентификатор) в функ. pc_contr, pc_rj


